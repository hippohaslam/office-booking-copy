#
# GitHub Actions CI/CD Workflow for the Hippo Booking (.NET + React) Application
#
# This workflow is designed to build, test, and deploy the full-stack application.
# It infers the application structure, testing strategies, and cloud infrastructure
# from the provided project files.
#
# Features:
# - Manual trigger with environment selection (Test/Production).
# - Comprehensive build and test stages for both .NET backend and React frontend.
# - Unit Testing: .NET and frontend unit tests run in parallel.
# - Integration Testing: .NET integration tests run against a live PostgreSQL container.
# - End-to-End Testing: Full application stack (API, Web, DB) is orchestrated using
#   Docker Compose to run Playwright E2E tests.
# - Infrastructure as Code: Manages AWS infrastructure using Terraform.
# - Deployment: Deploys the .NET API to AWS Elastic Beanstalk and the React frontend
#   to AWS Amplify.
#

name: .NET and React Full Stack CI/CD

# -----------------
# Workflow Settings
# -----------------
env:
  # AWS and Terraform Configuration
  AWS_REGION: 'eu-west-1'
  TERRAFORM_WORKING_DIR: 'src/infrastructure/terraform'

  # .NET Configuration
  DOTNET_VERSION: '8.0.x'
  SOLUTION_FILE_PATH: 'src/hippo-booking.sln'
  API_PROJECT_PATH: 'src/api/Hippo.Booking.API'

  # Frontend Configuration
  NODE_VERSION: '20.x'
  FRONTEND_WORKING_DIR: 'src/web/hippo-booking'

  # Artifact Configuration
  API_ARTIFACT_NAME: 'api-artifact'

# -----------------
# Workflow Triggers
# -----------------
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'The target environment for deployment'
        required: true
        type: choice
        options:
          - 'Test'
          - 'Production'

# -----------------
# Permissions
# -----------------
# This workflow uses static AWS credentials via secrets.
# If using OIDC, `id-token: write` would be required.
permissions:
  contents: read

# -----------------
# Jobs
# -----------------
jobs:
  # Job 1: Build & Test
  # Compiles all code, runs linters, unit tests, and integration tests.
  build_and_test:
    name: Build & Test
    runs-on: ubuntu-latest
    services:
      # Spin up a PostgreSQL container for integration tests
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        # Health check to ensure the database is ready before tests run
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: Setup Node.js and Yarn
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Setup Frontend (Corepack and Yarn)
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        run: |
          # Enable corepack to use the yarn version defined in package.json
          corepack enable
          yarn install --immutable

      - name: Lint Frontend
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        run: yarn lint

      - name: Run Frontend Unit Tests (Vitest)
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        run: yarn ci-test

      - name: Restore .NET Dependencies
        run: dotnet restore ${{ env.SOLUTION_FILE_PATH }}

      - name: Build .NET Solution
        run: dotnet build ${{ env.SOLUTION_FILE_PATH }} --configuration Release --no-restore

      - name: Run .NET Unit Tests
        run: |
          dotnet test src/api/tests/Hippo.Booking.Core.Tests/Hippo.Booking.Core.Tests.csproj --no-build --configuration Release --logger "trx;LogFileName=core_test_results.trx"
          dotnet test src/api/tests/Hippo.Booking.Application.Tests/Hippo.Booking.Application.Tests.csproj --no-build --configuration Release --logger "trx;LogFileName=application_test_results.trx"
          dotnet test src/api/tests/Hippo.Booking.Infrastructure.Tests/Hippo.Booking.Infrastructure.Tests.csproj --no-build --configuration Release --logger "trx;LogFileName=infrastructure_test_results.trx"

      - name: Run .NET Integration Tests
        run: dotnet test src/api/tests/Hippo.Booking.Integration.Tests/Hippo.Booking.Integration.Tests.csproj --no-build --configuration Release --logger "trx;LogFileName=integration_test_results.trx"
        env:
          # Override connection string from appsettings.json to use the service container
          ConnectionStrings__HippoBookingDbContext: "Host=localhost;Port=5432;Database=HippoBooking_Integration;Username=postgres;Password=postgres"

      - name: Publish .NET API for Deployment
        run: dotnet publish ${{ env.API_PROJECT_PATH }} --configuration Release --output ./api-publish /p:UseAppHost=false
      
      - name: Upload API Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}
          path: ./api-publish

  # Job 2: End-to-End Tests
  # Runs Playwright E2E tests against a full application stack.
  run_e2e_tests:
    name: End-to-End Tests
    needs: build_and_test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Build E2E Test Project
        run: dotnet build src/e2e/Hippo.Booking.E2ETests/Hippo.Booking.E2ETests.csproj -c Release

      - name: Install Playwright Browsers
        run: pwsh src/e2e/Hippo.Booking.E2ETests/bin/Release/net8.0/playwright.ps1 install --with-deps
      
      - name: Start Application Stack for E2E Tests
        run: >
          docker compose 
          -f src/infrastructure/docker/docker-compose-ci.yml 
          -f src/infrastructure/docker/docker-compose-services.yml
          up --build -d --wait
      
      - name: Run E2E Tests
        run: dotnet test src/e2e/Hippo.Booking.E2ETests/Hippo.Booking.E2ETests.csproj --no-build --configuration Release --logger "trx;LogFileName=e2e_test_results.trx"
        env:
          # Override URLs to ensure they match the non-HTTPS environment in docker-compose
          Urls__BaseUrl: "http://localhost:5173"
          ConnectionStrings__Database: "Server=localhost;Port=5432;User Id=postgres;Password=postgres;Database=HippoBooking_EndToEnd"

      - name: Stop Application Stack
        if: always()
        run: >
          docker compose 
          -f src/infrastructure/docker/docker-compose-ci.yml 
          -f src/infrastructure/docker/docker-compose-services.yml
          down

  # Job 3: Deploy to AWS
  # Provisions infrastructure with Terraform and deploys application artifacts.
  deploy:
    name: Deploy to ${{ github.event.inputs.environment }}
    needs: [build_and_test, run_e2e_tests]
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        id: init
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: >
          terraform init -backend-config="bucket=${{ secrets.TF_BACKEND_S3_BUCKET }}" 
          -backend-config="key=terraform/${{ github.event.inputs.environment }}/terraform.tfstate"
          -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform plan -var-file="${{ github.event.inputs.environment }}.tfvars" -out=tfplan -no-color
        env:
          # Pass secrets to terraform as TF_VAR environment variables
          TF_VAR_github_repo: ${{ github.repository }}
          TF_VAR_github_access_token: ${{ secrets.TF_VAR_GITHUB_ACCESS_TOKEN }}
          TF_VAR_google_client_secret: ${{ secrets.TF_VAR_GOOGLE_CLIENT_SECRET }}
          TF_VAR_google_credentials: ${{ secrets.TF_VAR_GOOGLE_CREDENTIALS }}
          TF_VAR_slack_token: ${{ secrets.TF_VAR_SLACK_TOKEN }}
          TF_VAR_slack_signing_secret: ${{ secrets.TF_VAR_SLACK_SIGNING_SECRET }}
          TF_VAR_slack_channel_email: ${{ secrets.TF_VAR_SLACK_CHANNEL_EMAIL }}

      - name: Terraform Apply
        id: apply
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform apply -auto-approve -no-color tfplan

      - name: Get Terraform Outputs
        id: outputs
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: echo "tf_outputs=$(terraform output -json)" >> $GITHUB_OUTPUT

      - name: Download API Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}
          path: ./api-publish

      - name: Create API Deployment Package
        working-directory: ./api-publish
        run: zip -r api-deployment.zip .
      
      - name: Deploy API to Elastic Beanstalk
        run: |
          EB_APP_NAME=$(echo '${{ steps.outputs.outputs.tf_outputs }}' | jq -r .elastic_beanstalk_application_name.value)
          EB_ENV_NAME=$(echo '${{ steps.outputs.outputs.tf_outputs }}' | jq -r .elastic_beanstalk_environment_name.value)
          VERSION_LABEL="v${{ github.run_id }}-${{ github.run_attempt }}"
          S3_BUCKET_NAME="${{ secrets.EB_ARTIFACTS_S3_BUCKET }}"
          S3_KEY="api-deployments/${EB_APP_NAME}/${VERSION_LABEL}.zip"

          echo "Deploying version ${VERSION_LABEL} to ${EB_ENV_NAME}"

          aws s3 cp ./api-publish/api-deployment.zip "s3://${S3_BUCKET_NAME}/${S3_KEY}"

          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APP_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${S3_BUCKET_NAME}",S3Key="${S3_KEY}"

          aws elasticbeanstalk update-environment \
            --environment-name "${EB_ENV_NAME}" \
            --version-label "${VERSION_LABEL}"

      - name: Trigger Frontend Deployment on Amplify
        run: |
          AMPLIFY_APP_NAME=$(echo '${{ steps.outputs.outputs.tf_outputs }}' | jq -r .amplify_app_name.value)
          AMPLIFY_APP_ID=$(aws amplify list-apps --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" --output text)
          
          echo "Starting Amplify deployment for app ID ${AMPLIFY_APP_ID} on branch main"
          
          aws amplify start-job --app-id "${AMPLIFY_APP_ID}" --branch-name main --job-type "RELEASE"
