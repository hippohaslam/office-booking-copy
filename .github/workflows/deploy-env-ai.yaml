# Comprehensive GitHub Actions workflow for building, testing, and deploying a .NET and React application to AWS.
# This workflow is generated based on the project structure and configuration files.

name: Build, Test, and Deploy Hippo Booking

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'Test'
        type: choice
        options:
          - Test
          - Production

# Define permissions for the GITHUB_TOKEN for OIDC and content access.
permissions:
  id-token: write # Required for OIDC authentication with AWS.
  contents: read  # Required to checkout the repository.

# Define reusable environment variables for the entire workflow.
env:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '20.x'
  AWS_REGION: 'eu-west-1'
  SOLUTION_FILE_PATH: 'src/hippo-booking.sln'
  API_PROJECT_PATH: 'src/api/Hippo.Booking.API/Hippo.Booking.API.csproj'
  WEB_APP_PATH: 'src/web/hippo-booking'
  E2E_TEST_PROJECT_PATH: 'src/e2e/Hippo.Booking.E2ETests/Hippo.Booking.E2ETests.csproj'
  INTEGRATION_TEST_PROJECT_PATH: 'src/api/tests/Hippo.Booking.Integration.Tests/Hippo.Booking.Integration.Tests.csproj'
  
jobs:
  build-and-unit-test:
    name: Build & Unit Test
    runs-on: ubuntu-latest
    outputs:
      web-artifact-name: ${{ steps.publish-web-artifact.outputs.artifact-name }}
      api-artifact-name: ${{ steps.publish-api-artifact.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore .NET dependencies and build solution
        run: dotnet build "${{ env.SOLUTION_FILE_PATH }}" --configuration Release

      - name: Run .NET Unit Tests
        run: >
          dotnet test "${{ env.SOLUTION_FILE_PATH }}" --configuration Release --no-build
          --filter "FullyQualifiedName!~Hippo.Booking.Integration.Tests&FullyQualifiedName!~Hippo.Booking.E2ETests"

      - name: Build and Test Frontend
        working-directory: ${{ env.WEB_APP_PATH }}
        run: |
          corepack enable
          yarn install --immutable
          yarn ci-test

      - name: Publish .NET API
        run: dotnet publish "${{ env.API_PROJECT_PATH }}" --configuration Release --output ${{ github.workspace }}/api-artifact

      - name: Publish Frontend
        id: publish-web
        working-directory: ${{ env.WEB_APP_PATH }}
        run: |
          env_lower=$(echo "${{ github.event.inputs.environment }}" | tr '[:upper:]' '[:lower:]')
          yarn build:$env_lower

      - name: Upload API Artifact
        id: publish-api-artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-artifact
          path: ${{ github.workspace }}/api-artifact/

      - name: Upload Web Artifact
        id: publish-web-artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-artifact
          path: ${{ env.WEB_APP_PATH }}/dist/

  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: build-and-unit-test
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        # Health check to ensure the database is ready before tests run.
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Run .NET Integration Tests
        # Override the connection string from appsettings.json to connect to the service container.
        env:
          ConnectionStrings__HippoBookingDbContext: "Host=localhost;Port=${{ job.services.postgres.ports[5432] }};Database=HippoBooking_Integration;Username=postgres;Password=postgres"
        run: dotnet test "${{ env.INTEGRATION_TEST_PROJECT_PATH }}" --configuration Release

  e2e-test:
    name: End-to-End Test
    runs-on: ubuntu-latest
    needs: build-and-unit-test
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Start services using Docker Compose
        run: |
          docker compose -f src/infrastructure/docker/docker-compose-ci.yml -f src/infrastructure/docker/docker-compose-services.yml up --build -d
          echo "Waiting for services to become healthy..."
          sleep 30 # Allow services time to start up and stabilize.
      
      - name: Verify services are running
        run: |
          docker compose ps
          curl --retry 10 --retry-delay 5 --retry-connrefused -f http://localhost:7249/health
          curl --retry 10 --retry-delay 5 --retry-connrefused -f http://localhost:5173

      - name: Install Playwright browsers
        run: |
          dotnet build ${{ env.E2E_TEST_PROJECT_PATH }}
          ${{ github.workspace }}/${{ env.E2E_TEST_PROJECT_PATH }}/bin/Debug/net8.0/playwright.ps1 install --with-deps
        shell: pwsh

      - name: Run .NET E2E Tests
        run: dotnet test "${{ env.E2E_TEST_PROJECT_PATH }}" --configuration Release
        
      - name: Stop services
        if: always()
        run: docker compose -f src/infrastructure/docker/docker-compose-ci.yml -f src/infrastructure/docker/docker-compose-services.yml down

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [integration-test, e2e-test]
    environment:
      name: ${{ github.event.inputs.environment }}
      url: ${{ steps.get-outputs.outputs.frontend_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionRole-${{ github.event.inputs.environment }}"
          aws-region: ${{ env.AWS_REGION }}

      - name: Download API Artifact
        uses: actions/download-artifact@v4
        with:
          name: api-artifact
          path: ${{ github.workspace }}/api-deploy

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.x

      - name: Terraform Init
        id: init
        run: |
          terraform init \
            -backend-config="bucket=hippo-booking-tf-state-${{ secrets.AWS_ACCOUNT_ID }}" \
            -backend-config="key=${{ github.event.inputs.environment }}.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"
        working-directory: src/infrastructure/terraform

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve -var-file="${{ github.event.inputs.environment }}.tfvars" \
            -var="github_repo=${{ github.repository }}" \
            -var="github_access_token=${{ secrets.GH_PAT_FOR_AMPLIFY }}" \
            -var="google_client_secret=${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            -var="slack_token=${{ secrets.SLACK_TOKEN }}" \
            -var="slack_signing_secret=${{ secrets.SLACK_SIGNING_SECRET }}" \
            -var="slack_channel_email=${{ secrets.SLACK_CHANNEL_EMAIL }}" \
            -var="google_credentials=${{ secrets.GOOGLE_CREDENTIALS }}"
        working-directory: src/infrastructure/terraform
        
      - name: Get Terraform Outputs
        id: get-outputs
        run: |
          terraform output -json > tf_outputs.json
          cat tf_outputs.json
          echo "beanstalk_app_name=$(jq -r '.elastic_beanstalk_application_name.value' tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "beanstalk_env_name=$(jq -r '.elastic_beanstalk_environment_name.value' tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "amplify_app_id=$(jq -r '.amplify_app_name.value | split("-") | .[0:(length-4)] | join("-")' tf_outputs.json)" # This extracts the ID from the name string, assuming a consistent naming convention from the amplify.tf file.
          echo "amplify_app_id=$(jq -r '.amplify_app_name.value' tf_outputs.json | sed 's/-front-end-.*//')" >> $GITHUB_ENV
          
          # Getting the actual amplify app ID is more reliable via AWS CLI
          APP_NAME=$(jq -r '.amplify_app_name.value' tf_outputs.json)
          AMPLIFY_APP_ID=$(aws amplify list-apps --query "apps[?name=='$APP_NAME'].appId" --output text)
          echo "AMPLIFY_APP_ID=$AMPLIFY_APP_ID" >> $GITHUB_ENV
          
          FRONTEND_URL=$(aws amplify get-app --app-id $AMPLIFY_APP_ID --query "app.defaultDomain" --output text)
          echo "frontend_url=https://$FRONTEND_URL" >> $GITHUB_OUTPUT
        working-directory: src/infrastructure/terraform

      - name: Create API Deployment Package
        run: zip -r api-deploy.zip .
        working-directory: ${{ github.workspace }}/api-deploy

      - name: Deploy API to Elastic Beanstalk
        run: |
          VERSION_LABEL="v${{ github.run_number }}-${{ github.sha }}"
          S3_BUCKET="elasticbeanstalk-${{ env.AWS_REGION }}-${{ secrets.AWS_ACCOUNT_ID }}"
          S3_KEY="${{ steps.get-outputs.outputs.beanstalk_app_name }}/${VERSION_LABEL}.zip"

          aws s3 cp ${{ github.workspace }}/api-deploy.zip s3://${S3_BUCKET}/${S3_KEY}

          aws elasticbeanstalk create-application-version \
            --application-name "${{ steps.get-outputs.outputs.beanstalk_app_name }}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${S3_BUCKET}",S3Key="${S3_KEY}"

          aws elasticbeanstalk update-environment \
            --environment-name "${{ steps.get-outputs.outputs.beanstalk_env_name }}" \
            --version-label "${VERSION_LABEL}"

      - name: Trigger Frontend Deployment on Amplify
        run: |
          aws amplify start-job \
            --app-id ${{ env.AMPLIFY_APP_ID }} \
            --branch-name main \
            --job-type RELEASE
