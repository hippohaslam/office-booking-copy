#
# GitHub Actions CI/CD Workflow for the Hippo.Booking Full-Stack .NET Application
#
# This workflow is generated based on the project structure and file contents. It orchestrates
# the build, testing (unit, integration, E2E), and deployment of the .NET API and React frontend
# to AWS using Terraform for infrastructure provisioning.
#

name: Hippo.Booking CI/CD

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - Test
          - Production

# Common environment variables for the workflow
env:
  # Tool Versions
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '20.x'

  # AWS Configuration
  AWS_REGION: 'eu-west-1'

  # Project Paths
  SOLUTION_FILE_PATH: ./src/hippo-booking.sln
  API_PROJECT_PATH: ./src/api/Hippo.Booking.API/Hippo.Booking.API.csproj
  WEB_PROJECT_PATH: ./src/web/hippo-booking

  # Artifact Names
  API_ARTIFACT_NAME: api-publish
  WEB_ARTIFACT_NAME: web-dist
  
permissions:
  id-token: write # Required for authenticating to AWS via OIDC
  contents: read  # Required to checkout the repository

jobs:
  ####################################################################################
  # BUILD & UNIT TEST JOB
  # - Builds the .NET API and React frontend.
  # - Runs all unit tests for both components.
  # - Publishes build artifacts for subsequent jobs.
  ####################################################################################
  build-and-unit-test:
    name: Build & Unit Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore .NET Dependencies
        run: dotnet restore ${{ env.SOLUTION_FILE_PATH }}

      - name: Build .NET Solution
        run: dotnet build ${{ env.SOLUTION_FILE_PATH }} --configuration Release --no-restore

      - name: Run .NET Unit Tests
        run: |
          dotnet test ./src/api/tests/Hippo.Booking.Core.Tests/ --configuration Release --no-build
          dotnet test ./src/api/tests/Hippo.Booking.Application.Tests/ --configuration Release --no-build
          dotnet test ./src/api/tests/Hippo.Booking.Infrastructure.Tests/ --configuration Release --no-build

      - name: Install Frontend Dependencies
        working-directory: ${{ env.WEB_PROJECT_PATH }}
        run: |
          corepack enable
          yarn install --immutable

      - name: Run Frontend Lint & Unit Tests
        working-directory: ${{ env.WEB_PROJECT_PATH }}
        run: |
          yarn lint
          yarn ci-test
      
      - name: Publish .NET API
        run: dotnet publish ${{ env.API_PROJECT_PATH }} --configuration Release --output ${{ github.workspace }}/api-publish

      - name: Build Frontend Application
        working-directory: ${{ env.WEB_PROJECT_PATH }}
        run: yarn build

      - name: Upload API Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}
          path: ${{ github.workspace }}/api-publish

      - name: Upload Web Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.WEB_ARTIFACT_NAME }}
          path: ${{ env.WEB_PROJECT_PATH }}/dist

  ####################################################################################
  # INTEGRATION TEST JOB
  # - Runs .NET integration tests against a real PostgreSQL database.
  # - The database is provisioned as a service container.
  ####################################################################################
  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: build-and-unit-test
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Run .NET Integration Tests
        run: dotnet test ./src/api/tests/Hippo.Booking.Integration.Tests/ --configuration Release
        env:
          ConnectionStrings__HippoBookingDbContext: "Host=localhost;Port=${{ job.services.postgres.ports[5432] }};Database=HippoBooking_Integration;Username=postgres;Password=postgres"

  ####################################################################################
  # END-TO-END TEST JOB
  # - Uses Docker Compose to build and run the full application stack (API, Web, DB).
  # - Executes Playwright E2E tests against the running application.
  ####################################################################################
  e2e-test:
    name: End-to-End Test
    runs-on: ubuntu-latest
    needs: build-and-unit-test
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Start Application Stack via Docker Compose
        run: docker compose -f ./src/infrastructure/docker/docker-compose-ci.yml -f ./src/infrastructure/docker/docker-compose-services.yml up --build -d --wait

      - name: Wait for Services to be Ready
        run: |
          echo "Waiting for API and Web services to become healthy..."
          timeout 120s bash -c 'until curl -k --silent --fail https://localhost:5173 && curl --silent --fail http://localhost:7249/health; do echo "Services not yet ready, sleeping..."; sleep 5; done'
          echo "All services are ready."

      - name: Run Playwright E2E Tests
        run: dotnet test ./src/e2e/Hippo.Booking.E2ETests/ --configuration Release
        env:
          Urls__BaseUrl: "https://localhost:5173/"
          ConnectionStrings__Database: "Host=localhost;Port=5432;User Id=postgres;Password=postgres;Database=HippoBooking_EndToEnd"
          
      - name: Teardown Application Stack
        if: always()
        run: docker compose -f ./src/infrastructure/docker/docker-compose-ci.yml -f ./src/infrastructure/docker/docker-compose-services.yml down

  ####################################################################################
  # DEPLOY JOB
  # - Provisions or updates cloud infrastructure using Terraform.
  # - Deploys the .NET API to AWS Elastic Beanstalk.
  # - Triggers a new build and deployment on AWS Amplify for the frontend.
  ####################################################################################
  deploy:
    name: Deploy to ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    needs: [integration-test, e2e-test]
    environment:
      name: ${{ github.event.inputs.environment }}
      # url: (will be set dynamically)
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }} # e.g., arn:aws:iam::123456789012:role/GitHubActionRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Download API Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}
          path: ${{ github.workspace }}/api-publish

      - name: Terraform Init
        id: tf-init
        run: terraform -chdir=./src/infrastructure/terraform init
        env:
          # Assuming S3 backend is configured in provider.tf and the role has access
          AWS_ACCESS_KEY_ID: ${{ steps.aws-creds.outputs.aws-access-key-id }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.aws-creds.outputs.aws-secret-access-key }}
          AWS_SESSION_TOKEN: ${{ steps.aws-creds.outputs.aws-session-token }}

      - name: Terraform Apply
        id: tf-apply
        run: terraform -chdir=./src/infrastructure/terraform apply -var-file="${{ github.event.inputs.environment }}.tfvars" -auto-approve
        env:
          # Pass sensitive variables required by Terraform
          TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TF_VAR_slack_token: ${{ secrets.SLACK_TOKEN }}
          TF_VAR_slack_signing_secret: ${{ secrets.SLACK_SIGNING_SECRET }}
          TF_VAR_github_access_token: ${{ secrets.REPO_ACCESS_TOKEN }}
          TF_VAR_google_credentials: ${{ secrets.GOOGLE_CREDENTIALS_JSON }}
          TF_VAR_slack_channel_email: ${{ secrets.SLACK_CHANNEL_EMAIL }}
          TF_VAR_github_repo: ${{ github.repositoryUrl }}

      - name: Get Terraform Outputs
        id: tf-outputs
        run: echo "outputs=$(terraform -chdir=./src/infrastructure/terraform output -json)" >> $GITHUB_OUTPUT

      - name: Package API for Elastic Beanstalk
        run: |
          cd api-publish
          zip -r ../api-deployment.zip .

      - name: Deploy API to Elastic Beanstalk
        id: deploy-api
        run: |
          EB_APP_NAME=$(echo '${{ steps.tf-outputs.outputs.elastic_beanstalk_application_name }}' | jq -r '.value')
          EB_ENV_NAME=$(echo '${{ steps.tf-outputs.outputs.elastic_beanstalk_environment_name }}' | jq -r '.value')
          S3_BUCKET="elasticbeanstalk-${{ env.AWS_REGION }}-${{ secrets.AWS_ACCOUNT_ID }}"
          VERSION_LABEL="v${{ github.sha }}-${{ github.run_id }}"
          S3_KEY="${EB_APP_NAME}/${VERSION_LABEL}.zip"

          aws s3 cp api-deployment.zip "s3://${S3_BUCKET}/${S3_KEY}"

          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APP_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle "S3Bucket=${S3_BUCKET},S3Key=${S3_KEY}"

          aws elasticbeanstalk update-environment \
            --environment-name "${EB_ENV_NAME}" \
            --version-label "${VERSION_LABEL}"

      - name: Trigger Frontend Deployment on Amplify
        id: deploy-frontend
        run: |
          AMPLIFY_APP_NAME=$(echo '${{ steps.tf-outputs.outputs.amplify_app_name }}' | jq -r '.value')
          AMPLIFY_APP_ID=$(aws amplify list-apps --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" --output text)
          
          aws amplify start-job --app-id "${AMPLIFY_APP_ID}" --branch-name main --job-type RELEASE
          
          echo "Amplify deployment triggered for app ${AMPLIFY_APP_NAME} (ID: ${AMPLIFY_APP_ID}). Monitor progress in the AWS Amplify Console."
