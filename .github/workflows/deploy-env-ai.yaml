name: .NET and React CI/CD with Terraform on AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        type: choice
        options:
          - Test
          - Production

env:
  # .NET settings
  DOTNET_VERSION: '8.0.x'
  SOLUTION_PATH: src/hippo-booking.sln
  API_PROJECT_PATH: src/api/Hippo.Booking.API/Hippo.Booking.API.csproj
  INTEGRATION_TEST_PROJECT_PATH: src/api/tests/Hippo.Booking.Integration.Tests/Hippo.Booking.Integration.Tests.csproj
  E2E_TEST_PROJECT_PATH: src/e2e/Hippo.Booking.E2ETests/Hippo.Booking.E2ETests.csproj
  
  # Node.js settings
  NODE_VERSION: '20.x'
  WEB_PROJECT_PATH: src/web/hippo-booking
  
  # Artifacts
  API_ARTIFACT_NAME: api-artifact
  WEB_ARTIFACT_NAME: web-artifact
  API_PUBLISH_DIR: api-publish
  
  # AWS settings
  AWS_REGION: eu-west-1

permissions:
  id-token: write
  contents: read

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    services:
      postgres-integration:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: mystrong!Pa55word
          POSTGRES_DB: HippoBooking_Integration
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d HippoBooking_Integration"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Build and Test Frontend
        working-directory: ${{ env.WEB_PROJECT_PATH }}
        run: |
          corepack enable
          yarn install --immutable
          yarn build
          yarn ci-test

      - name: Restore .NET dependencies
        run: dotnet restore ${{ env.SOLUTION_PATH }}

      - name: Build .NET Solution
        run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release --no-restore

      - name: Run .NET Unit Tests
        run: dotnet test ${{ env.SOLUTION_PATH }} --configuration Release --no-build --filter "TestCategory!=Integration&TestCategory!=E2E"

      - name: Run .NET Integration Tests
        env:
          ConnectionStrings__HippoBookingDbContext: "Server=localhost;Port=${{ job.services.postgres-integration.ports[5432] }};Database=HippoBooking_Integration;User Id=postgres;Password=mystrong!Pa55word;"
        run: dotnet test ${{ env.INTEGRATION_TEST_PROJECT_PATH }} --configuration Release --no-build --filter "TestCategory=Integration"

      - name: Publish .NET API
        run: dotnet publish ${{ env.API_PROJECT_PATH }} --configuration Release --output ${{ env.API_PUBLISH_DIR }}

      - name: Package API Artifact
        run: |
          cd ${{ env.API_PUBLISH_DIR }}
          zip -r ../${{ env.API_ARTIFACT_NAME }}.zip .

      - name: Upload API Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}
          path: ${{ env.API_ARTIFACT_NAME }}.zip

      - name: Upload Web Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.WEB_ARTIFACT_NAME }}
          path: ${{ env.WEB_PROJECT_PATH }}/dist

  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Playwright Browsers
        run: |
          dotnet tool install --global Microsoft.Playwright.CLI
          playwright install --with-deps

      - name: Start Application Stack for E2E Tests
        run: |
          docker compose -f src/infrastructure/docker/docker-compose-ci.yml -f src/infrastructure/docker/docker-compose-services.yml up -d --wait

      - name: Wait for API to be healthy
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:7249/health; then
              echo "API is healthy!"
              break
            fi
            echo "Waiting for API... ($i/30)"
            sleep 5
          done
          curl -sf --fail http://localhost:7249/health

      - name: Run Playwright E2E Tests
        run: dotnet test ${{ env.E2E_TEST_PROJECT_PATH }} --configuration Release

      - name: Stop Application Stack
        if: always()
        run: docker compose -f src/infrastructure/docker/docker-compose-ci.yml -f src/infrastructure/docker/docker-compose-services.yml down

  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: e2e-tests
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.print_urls.outputs.frontend_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download API Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.API_ARTIFACT_NAME }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0 # Specify a version for consistency

      - name: Terraform Init
        id: init
        working-directory: src/infrastructure/terraform
        env:
          AWS_BUCKET_NAME: ${{ secrets.TF_STATE_BUCKET }}
          AWS_BUCKET_KEY: "terraform.tfstate"
        run: terraform init -backend-config="bucket=$AWS_BUCKET_NAME" -backend-config="key=$AWS_BUCKET_KEY" -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        id: plan
        working-directory: src/infrastructure/terraform
        run: terraform plan -var-file="${{ inputs.environment }}.tfvars" -no-color
        env:
          TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TF_VAR_slack_token: ${{ secrets.SLACK_TOKEN }}
          TF_VAR_slack_signing_secret: ${{ secrets.SLACK_SIGNING_SECRET }}
          TF_VAR_github_repo: ${{ github.repository }}
          TF_VAR_github_access_token: ${{ secrets.GH_PAT_FOR_AMPLIFY }}
          TF_VAR_slack_channel_email: ${{ secrets.SLACK_CHANNEL_EMAIL }}
          TF_VAR_google_credentials: ${{ secrets.GOOGLE_CREDENTIALS }}

      - name: Terraform Apply
        id: apply
        working-directory: src/infrastructure/terraform
        run: terraform apply -auto-approve -var-file="${{ inputs.environment }}.tfvars"
        env:
          TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TF_VAR_slack_token: ${{ secrets.SLACK_TOKEN }}
          TF_VAR_slack_signing_secret: ${{ secrets.SLACK_SIGNING_SECRET }}
          TF_VAR_github_repo: ${{ github.repository }}
          TF_VAR_github_access_token: ${{ secrets.GH_PAT_FOR_AMPLIFY }}
          TF_VAR_slack_channel_email: ${{ secrets.SLACK_CHANNEL_EMAIL }}
          TF_VAR_google_credentials: ${{ secrets.GOOGLE_CREDENTIALS }}

      - name: Get Terraform Outputs
        id: tf_outputs
        working-directory: src/infrastructure/terraform
        run: |
          echo "eb_app_name=$(terraform output -raw elastic_beanstalk_application_name)" >> $GITHUB_OUTPUT
          echo "eb_env_name=$(terraform output -raw elastic_beanstalk_environment_name)" >> $GITHUB_OUTPUT
          echo "amplify_app_name=$(terraform output -raw amplify_app_name)" >> $GITHUB_OUTPUT
      
      - name: Deploy API to Elastic Beanstalk
        id: eb_deploy
        run: |
          VERSION_LABEL="v${{ github.run_number }}-${{ github.sha }}"
          EB_APP_NAME="${{ steps.tf_outputs.outputs.eb_app_name }}"
          EB_ENV_NAME="${{ steps.tf_outputs.outputs.eb_env_name }}"
          S3_STORAGE=$(aws elasticbeanstalk create-storage-location --region ${{ env.AWS_REGION }} | jq -r .S3Bucket)
          S3_KEY="${EB_APP_NAME}/${VERSION_LABEL}.zip"

          echo "Uploading artifact to s3://${S3_STORAGE}/${S3_KEY}"
          aws s3 cp ${{ env.API_ARTIFACT_NAME }}.zip s3://${S3_STORAGE}/${S3_KEY}

          echo "Creating Elastic Beanstalk application version ${VERSION_LABEL}"
          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APP_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${S3_STORAGE}",S3Key="${S3_KEY}"

          echo "Updating Elastic Beanstalk environment ${EB_ENV_NAME}"
          aws elasticbeanstalk update-environment \
            --environment-name "${EB_ENV_NAME}" \
            --version-label "${VERSION_LABEL}"

      - name: Trigger Frontend Deployment on Amplify
        id: amplify_deploy
        run: |
          AMPLIFY_APP_NAME="${{ steps.tf_outputs.outputs.amplify_app_name }}"
          AMPLIFY_APP_ID=$(aws amplify list-apps --region ${{ env.AWS_REGION }} | jq -r ".apps[] | select(.name==\"${AMPLIFY_APP_NAME}\") | .appId")
          
          echo "Starting Amplify build for App ID: ${AMPLIFY_APP_ID}"
          aws amplify start-job --app-id "${AMPLIFY_APP_ID}" --branch-name main --job-type RELEASE

      - name: Print Deployed URLs
        id: print_urls
        run: |
          EB_URL=$(aws elasticbeanstalk describe-environments --environment-names ${{ steps.tf_outputs.outputs.eb_env_name }} --query "Environments[0].CNAME" --output text)
          AMPLIFY_APP_ID=$(aws amplify list-apps --region ${{ env.AWS_REGION }} | jq -r ".apps[] | select(.name==\"${{ steps.tf_outputs.outputs.amplify_app_name }}\") | .appId")
          AMPLIFY_URL=$(aws amplify get-app --app-id ${AMPLIFY_APP_ID} | jq -r ".app.defaultDomain")
          echo "Backend URL: http://${EB_URL}"
          echo "Frontend URL: https://${AMPLIFY_URL}"
          echo "frontend_url=https://${AMPLIFY_URL}" >> $GITHUB_OUTPUT
